Промисы (Promise) Скопировать ссылку на секцию "Промисы (Promise)" Промис — это объект-обёртка для асинхронного кода. Он содержит в себе состояние: вначале pending («ожидание»), затем — одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»). В понятиях цикла событий промис работает так же, как колбэк: функция, которая должна выполниться (resolve или reject), находится в окружении Web API, а при наступлении события — попадает в очередь задач, откуда потом — в стек вызова. В асинхронных задачах есть разделение между макрозадачами и микрозадачами. Колбэки в промисах попадают в очередь микрозадач, тогда как колбэк в setTimeout() — в очередь макрозадач. Но здесь и сейчас мы в такие детали уходить не будем. Промисы придумали, чтобы организовывать асинхронный код последовательно. Та же последовательность запросов из прошлого примера, но переписанная с использованием промисов. Если что-то пошло не так, то программа не упадёт, а управление перейдёт к последней строчке с catch(), причём независимо от того, в каком из запросов ошибка появится. Также из then() можно вернуть не промис, а обычное значение. Оно обернётся в промис самостоятельно и прокинется в следующий then().
У них есть несколько недостатков:
Код не такой лаконичный, как мог быть. В цепочке промисов, как на примере (со стрелочными функциями), невозможно выставить брейкпоинт, потому что нет тела функции. Приходится раскрывать функцию. Стек ошибок может содержать в себе then.then.then.then.... Вложенные условия сильно увеличивают количество кода и ухудшают читаемость. Для решения этих проблем придумали асинхронные функции.
Связка async/await Скопировать ссылку на секцию "Связка async/await" Внутри асинхронных функций можно вызывать другие асинхронные функции, без каких-либо then() или колбэков, с помощью ключевого слова await. Код чище и короче. У нас больше нет цепочек из then(), вместо этого мы получаем плоскую структуру, которая по виду похожа на синхронный код. Условия и вложенные конструкции становятся чище и проще читаются. Мы можем обрабатывать ошибки с try-catch. Как и с синхронным кодом, обработка ошибок сводится к оборачиванию опасных операций в try-catch. При этом в отличие от .catch() промисов, try-catch поймает не только ошибки, которые были внутри асинхронных функций, но также и ошибки, которые возникли во время обычных синхронных операций.
dddddddddddddddddddddddddd
1234567
fdsa